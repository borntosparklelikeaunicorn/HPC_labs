# Задание
### Сумма элементов вектора
**Задача:** реализовать алгоритм сложения элементов вектора  
**Язык:** C++ или Python  
**Входные данные:** Вектор размером 1 000...1 000 000 значений  
**Выходные данные:** сумма элементов вектора + время вычисления  
Реализация должна содержать 2 функции сложения элементов вектора: на CPU и на GPU с применением CUDA.

# Описание проделанной работы
Данная лабораторная работа была выполнена на языке Python в Google Collab.

**CPU:** функция `cpu_sum` использует последовательное суммирование.

**GPU:** функция `gpu_sum` используется для параллельного суммирования. В ядре `gpu_sum_kernel` каждый поток обрабатывает свой элемент вектора и использует блоки потоков для ускорения, что позволяет GPU выполнять суммирование параллельно и быстрее, чем однопоточный CPU. `cuda.grid(1)` задаёт индексы потоков, чтобы каждый из них обрабатывал свой элемент.

# Анализ результатов эксперимента
Было произведено суммирование элементов вектора разного размера (1000, 5000, 10000, 50000, 100000, 500000, 1000000) на CPU и GPU. В таблице ниже представлены результаты эксперимента:
| Размер вектора | Время на CPU (с) | Время на GPU (с) | Ускорение |
|----------------|------------------|-------------------|-----------|
| 1000          | 0.000398         | 0.001805         | 0.22      |
| 5000          | 0.001851         | 0.001084         | 1.71      |
| 10000         | 0.002857         | 0.001024         | 2.79      |
| 50000         | 0.013008         | 0.001481         | 8.79      |
| 100000        | 0.021059         | 0.000805         | 26.16     |
| 500000        | 0.112022         | 0.001659         | 67.52     |
| 1000000      | 0.227435         | 0.002632         | 86.42     |

Время на CPU увеличивается линейно с ростом размера вектора. На GPU время выполнения остаётся почти постоянным, поскольку каждый поток обрабатывает часть массива одновременно. Колебания времени связаны с накладными расходами на передачу данных между памятью CPU и GPU. При малых размерах массива GPU показывает низкое ускорение, из-за накладных расходов на запуск ядра. С увеличением размера данных ускорение значительно возрастает.

Также ниже приведены графики зависимости времени выполнения программы от размера вектора, а также график ускорения GPU относительно CPU.
![image](https://github.com/user-attachments/assets/99615a23-313f-4562-af0f-6ea0bb53045b)
![image](https://github.com/user-attachments/assets/8d77b400-9aa7-495d-b0a5-d30c4c7a2ae5)
![image](https://github.com/user-attachments/assets/9f85b1a7-0afd-4360-af1e-ca60254ff142)

Таким образом, в ходе работы была проведена оценка производительности суммирования элементов вектора на CPU и GPU. Для малых размеров CPU показал хорошее время выполнения из-за меньших накладных расходов. Однако с увеличением размера данных GPU значительно выигрывает за счёт параллельной обработки, что подтверждает эффективность использования GPU для обработки больших объёмов данных.
